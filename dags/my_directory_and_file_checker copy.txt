from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.operators.empty import EmptyOperator
from datetime import datetime
import os
import pandas as pd
from datetime import datetime

import logging




# Configuration du logging
LOG_FILE = "errors.log"
logging.basicConfig(filename=LOG_FILE, level=logging.ERROR, format="%(asctime)s - %(levelname)s - %(message)s")


# Colonnes attendues et leurs types
EXPECTED_COLUMNS = ['Date comptabilisation', 'NÂ° lot', 'Type document']

COLUMN_TYPES = {
    'Date comptabilisation': datetime,  # La colonne doit contenir des dates
    'NÂ°lot': int,                      # La colonne doit contenir des entiers
    'type document': str               # La colonne doit Ãªtre une chaÃ®ne de caractÃ¨res
}

# DÃ©finition des variables
#DIRECTORY_PATH = "/opt/airflow/dags/shares"  # Remplacez par votre chemin
DIRECTORY_PATH = "/opt/airflow/files"  # Remplacez par votre chemin
ALLOWED_TYPES = [".csv"]  # Types de fichiers acceptÃ©s
ENCODINGS = ["utf-8", "ISO-8859-1", "Windows-1252"]  # Liste des encodages possibles




os.makedirs(DIRECTORY_PATH, exist_ok=True)



def log_message(filename, message):
    """Ã‰crit un message dans un fichier log."""
    file_path = os.path.join(DIRECTORY_PATH, filename)  # Chemin du fichier dans logs/
    with open(file_path, "a", encoding="utf-8") as log_file:
        log_file.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")
 

# Fonction pour vÃ©rifier l'existence du rÃ©pertoire
def check_directory():
    print('borusss',os.listdir(DIRECTORY_PATH))
    if os.path.isdir(DIRECTORY_PATH):
        return "check_file_in_directory"
    else:
        return "end"

# Fonction pour vÃ©rifier l'existence d'un type de fichier spÃ©cifique
def check_file_in_directory():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]
    if files:
        return "verify_file_reliability"
    else:
        return "end"

def read_file(file,file_path,ENCODINGS)->pd:
    result_read_file:pd=None
    for encoding in ENCODINGS:
        try:
            df = pd.read_csv(file_path, encoding=encoding, delimiter=";")
            print(f"\nğŸ“‚ Contenu du fichier ({encoding}): {file}")
            print(df.head())  # Afficher les premiÃ¨res lignes
            result_read_file=df
            break  # Sortir de la boucle si la lecture rÃ©ussit
        except UnicodeDecodeError as e:
            logging.error(f"âŒ Erreur d'encodage ({encoding}) pour {file}: {e}")
        except Exception as e:
            logging.error(f"âš ï¸ Erreur lors de la lecture de {file} avec {encoding}: {e}")
            break  # Ne pas tester d'autres encodages si une autre erreur survient
    return result_read_file
# Lire chaque fichier valide
"""
def read_files():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]

    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        try:
            df = pd.read_csv(file_path, encoding="utf-8", delimiter=";") #, on_bad_lines="skip"
        except UnicodeDecodeError:
            df = pd.read_csv(file_path, encoding="ISO-8859-1", delimiter=";")
        print(f"\nğŸ“‚ Contenu du fichier: {file}")
        print(df)
"""
"""
def read_files(DIRECTORY_PATH,ALLOWED_TYPES):
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]

    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        try:
            df = pd.read_csv(file_path, encoding="utf-8", delimiter=";")
        except UnicodeDecodeError as e:
            logging.error(f"Erreur d'encodage pour le fichier {file}: {e}")
            try:
                df = pd.read_csv(file_path, encoding="ISO-8859-1", delimiter=";")
                logging.error(f"Erreur lors de la lecture du fichier {file} en ISO-8859-1: {e}")
            except Exception as e:
                logging.error(f"Erreur lors de la lecture du fichier {file} en ISO-8859-1: {e}")
                continue  # Passe au fichier suivant si la lecture Ã©choue
        except Exception as e:
            logging.error(f"Erreur inattendue pour le fichier {file}: {e}")
            continue  # Passe au fichier suivant

        print(f"\nğŸ“‚ Contenu du fichier: {file}")
        print(df.head())  # Afficher seulement les premiÃ¨res lignes pour Ã©viter trop de texte
"""
"""
def check_file_reliability(file_path):
    try:
        # Charger le fichier CSV dans un DataFrame pandas
        df = pd.read_csv(file_path, encoding="utf-8", delimiter=";")
        # VÃ©rifier si toutes les colonnes attendues sont prÃ©sentes
        missing_columns = [col for col in EXPECTED_COLUMNS if col not in df.columns]
        if missing_columns:
            raise ValueError(f"Colonnes manquantes: {', '.join(missing_columns)}")

        # VÃ©rifier les types de donnÃ©es des colonnes
        for column, expected_type in COLUMN_TYPES.items():
            if column in df.columns:
                for value in df[column]:
                    if expected_type == datetime:
                        # VÃ©rifier si la valeur peut Ãªtre convertie en date
                        try:
                            datetime.strptime(str(value), "%Y-%m-%d")
                        except ValueError:
                            raise ValueError(f"Date invalide dans la colonne '{column}': {value}")
                    elif not isinstance(value, expected_type):
                        raise ValueError(f"Type de donnÃ©e invalide dans la colonne '{column}': {value} n'est pas du type {expected_type}")

        print("âœ… Le fichier respecte les colonnes attendues et les types de donnÃ©es.")
    
    except Exception as e:
        print(f"âŒ Erreur de fiabilitÃ© : {str(e)}")
        raise  # Relancer l'erreur pour Ã©chouer la tÃ¢che
"""



def check_file_reliability(pdf)->bool:
    result_check=False
    try:
        # VÃ©rifier si toutes les colonnes attendues sont prÃ©sentes
        missing_columns = [col for col in EXPECTED_COLUMNS if col not in pdf.columns];
        if missing_columns:
            #Ecrire dans le log
            raise ValueError(f"Colonnes manquantes: {', '.join(missing_columns)}")
        # VÃ©rifier les types de donnÃ©es des colonnes
        for column, expected_type in COLUMN_TYPES.items():
            if column in pdf.columns:
                for idx,value in enumerate(pdf[column]):
                    if expected_type == datetime:
                        date_formatted = pd.to_datetime(value, format="%d/%m/%Y").strftime("%Y-%m-%d")
                        if(datetime.strptime(str(date_formatted), "%Y-%m-%d")):
                            print('âœ…jean645888258', date_formatted)
                            error_msg = f"âŒ Erreur de format dans ligne:'{idx}' '{column}' : {value}"
                            print(error_msg)
                            log_message("succes_date_execution.txt", error_msg)
                            result_check=True
                        else:
                            print('Erreur sur le format de date', column,'-',value,'-',date_formatted)
                            print(f"Date invalide dans la colonne '{column}': {value}")
                            log_message("error_date_execution.txt", error_msg)
                            result_check=False
                    elif not isinstance(value, expected_type):
                            result_check=False
                            print(f"Erreur Type de donnÃ©e invalide dans la colonne '{column}': {value} n'est pas du type {expected_type}")
                            log_message("error_date_execution.txt", error_msg)

                    else:
                            result_check=True
                            log_message("succes_date_execution.txt", error_msg)

        error_msg=("âœ… Le fichier respecte les colonnes attendues et les types de donnÃ©es.",result_check)
        row_count = len(pdf)
        print('âœ…Lignes ',error_msg,row_count)
        log_message("statu_date_execution.txt", error_msg)

        return result_check

    except Exception as e:
        error_msg=(f"âŒ Erreur de fiabilitÃ© : {str(e)}")
        print(error_msg)
        log_message("error_date_execution.txt", error_msg)

        return False





# DÃ©finir la tÃ¢che de vÃ©rification de fiabilitÃ© du fichier
def verify_file_reliability():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]
    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        pdFile= read_file(file,file_path,ENCODINGS)
        if pdFile is not None:
            if check_file_reliability(pdFile):
                print('merci')
                return 'end'
            else:
                print('Merde')
                return 

        else:
            #Ecrire dans le log
            print(file_path,file,' non traitÃ© Boris',pdFile)
            return 







default_args = {
    "owner": "airflow",
    "start_date": datetime(2024, 1, 1),
}

with DAG("directory_and_file_verification_dag", default_args=default_args, 
             tags=['boris', 'bahi'],
             schedule_interval=None) as dag:

    # PremiÃ¨re tÃ¢che : vÃ©rifier si le rÃ©pertoire existe
    check_directory_task = BranchPythonOperator(
        task_id="check_directory",
        python_callable=check_directory
    )

    # DeuxiÃ¨me tÃ¢che : vÃ©rifier l'existence d'un type de fichier spÃ©cifique
    check_file_task = BranchPythonOperator(
        task_id="check_file_in_directory",
        python_callable=check_file_in_directory
    )
    """
   # TÃ¢che 3: Lire chaque fichier si trouvÃ©
    read_files_task = BranchPythonOperator(
        task_id="read_files",
        python_callable=read_files
    )"""

    verify_file_reliability_task = BranchPythonOperator(
    task_id='verify_file_reliability',
    python_callable=verify_file_reliability,
)


    # TÃ¢che de fin si aucun fichier valide ou rÃ©pertoire inexistant
    end_task = EmptyOperator(task_id="end")

   # DÃ©finition des dÃ©pendances
    #check_directory_task >> check_file_task >> read_files_task >> verify_file_reliability_task >> end_task
    check_directory_task >> check_file_task >> verify_file_reliability_task >> end_task

    # Si le rÃ©pertoire n'existe pas, on termine directement
    check_directory_task >> end_task
    # Si aucun fichier n'est trouvÃ©, on termine directement
    check_file_task >> end_task
    
    #read_files_task >> end_task

    # Si la vÃ©rification des fichiers Ã©choue, on termine directement
    verify_file_reliability_task >> end_task