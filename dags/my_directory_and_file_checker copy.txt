from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.operators.empty import EmptyOperator
from datetime import datetime
import os
import pandas as pd
from datetime import datetime

import logging




# Configuration du logging
LOG_FILE = "errors.log"
logging.basicConfig(filename=LOG_FILE, level=logging.ERROR, format="%(asctime)s - %(levelname)s - %(message)s")


# Colonnes attendues et leurs types
EXPECTED_COLUMNS = ['Date comptabilisation', 'N¬∞ lot', 'Type document']

COLUMN_TYPES = {
    'Date comptabilisation': datetime,  # La colonne doit contenir des dates
    'N¬∞lot': int,                      # La colonne doit contenir des entiers
    'type document': str               # La colonne doit √™tre une cha√Æne de caract√®res
}

# D√©finition des variables
#DIRECTORY_PATH = "/opt/airflow/dags/shares"  # Remplacez par votre chemin
DIRECTORY_PATH = "/opt/airflow/files"  # Remplacez par votre chemin
ALLOWED_TYPES = [".csv"]  # Types de fichiers accept√©s
ENCODINGS = ["utf-8", "ISO-8859-1", "Windows-1252"]  # Liste des encodages possibles




os.makedirs(DIRECTORY_PATH, exist_ok=True)



def log_message(filename, message):
    """√âcrit un message dans un fichier log."""
    file_path = os.path.join(DIRECTORY_PATH, filename)  # Chemin du fichier dans logs/
    with open(file_path, "a", encoding="utf-8") as log_file:
        log_file.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")
 

# Fonction pour v√©rifier l'existence du r√©pertoire
def check_directory():
    print('borusss',os.listdir(DIRECTORY_PATH))
    if os.path.isdir(DIRECTORY_PATH):
        return "check_file_in_directory"
    else:
        return "end"

# Fonction pour v√©rifier l'existence d'un type de fichier sp√©cifique
def check_file_in_directory():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]
    if files:
        return "verify_file_reliability"
    else:
        return "end"

def read_file(file,file_path,ENCODINGS)->pd:
    result_read_file:pd=None
    for encoding in ENCODINGS:
        try:
            df = pd.read_csv(file_path, encoding=encoding, delimiter=";")
            print(f"\nüìÇ Contenu du fichier ({encoding}): {file}")
            print(df.head())  # Afficher les premi√®res lignes
            result_read_file=df
            break  # Sortir de la boucle si la lecture r√©ussit
        except UnicodeDecodeError as e:
            logging.error(f"‚ùå Erreur d'encodage ({encoding}) pour {file}: {e}")
        except Exception as e:
            logging.error(f"‚ö†Ô∏è Erreur lors de la lecture de {file} avec {encoding}: {e}")
            break  # Ne pas tester d'autres encodages si une autre erreur survient
    return result_read_file
# Lire chaque fichier valide
"""
def read_files():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]

    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        try:
            df = pd.read_csv(file_path, encoding="utf-8", delimiter=";") #, on_bad_lines="skip"
        except UnicodeDecodeError:
            df = pd.read_csv(file_path, encoding="ISO-8859-1", delimiter=";")
        print(f"\nüìÇ Contenu du fichier: {file}")
        print(df)
"""
"""
def read_files(DIRECTORY_PATH,ALLOWED_TYPES):
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]

    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        try:
            df = pd.read_csv(file_path, encoding="utf-8", delimiter=";")
        except UnicodeDecodeError as e:
            logging.error(f"Erreur d'encodage pour le fichier {file}: {e}")
            try:
                df = pd.read_csv(file_path, encoding="ISO-8859-1", delimiter=";")
                logging.error(f"Erreur lors de la lecture du fichier {file} en ISO-8859-1: {e}")
            except Exception as e:
                logging.error(f"Erreur lors de la lecture du fichier {file} en ISO-8859-1: {e}")
                continue  # Passe au fichier suivant si la lecture √©choue
        except Exception as e:
            logging.error(f"Erreur inattendue pour le fichier {file}: {e}")
            continue  # Passe au fichier suivant

        print(f"\nüìÇ Contenu du fichier: {file}")
        print(df.head())  # Afficher seulement les premi√®res lignes pour √©viter trop de texte
"""
"""
def check_file_reliability(file_path):
    try:
        # Charger le fichier CSV dans un DataFrame pandas
        df = pd.read_csv(file_path, encoding="utf-8", delimiter=";")
        # V√©rifier si toutes les colonnes attendues sont pr√©sentes
        missing_columns = [col for col in EXPECTED_COLUMNS if col not in df.columns]
        if missing_columns:
            raise ValueError(f"Colonnes manquantes: {', '.join(missing_columns)}")

        # V√©rifier les types de donn√©es des colonnes
        for column, expected_type in COLUMN_TYPES.items():
            if column in df.columns:
                for value in df[column]:
                    if expected_type == datetime:
                        # V√©rifier si la valeur peut √™tre convertie en date
                        try:
                            datetime.strptime(str(value), "%Y-%m-%d")
                        except ValueError:
                            raise ValueError(f"Date invalide dans la colonne '{column}': {value}")
                    elif not isinstance(value, expected_type):
                        raise ValueError(f"Type de donn√©e invalide dans la colonne '{column}': {value} n'est pas du type {expected_type}")

        print("‚úÖ Le fichier respecte les colonnes attendues et les types de donn√©es.")
    
    except Exception as e:
        print(f"‚ùå Erreur de fiabilit√© : {str(e)}")
        raise  # Relancer l'erreur pour √©chouer la t√¢che
"""



def check_file_reliability(pdf)->bool:
    result_check=False
    try:
        # V√©rifier si toutes les colonnes attendues sont pr√©sentes
        missing_columns = [col for col in EXPECTED_COLUMNS if col not in pdf.columns];
        if missing_columns:
            #Ecrire dans le log
            raise ValueError(f"Colonnes manquantes: {', '.join(missing_columns)}")
        # V√©rifier les types de donn√©es des colonnes
        for column, expected_type in COLUMN_TYPES.items():
            if column in pdf.columns:
                for idx,value in enumerate(pdf[column]):
                    if expected_type == datetime:
                        date_formatted = pd.to_datetime(value, format="%d/%m/%Y").strftime("%Y-%m-%d")
                        if(datetime.strptime(str(date_formatted), "%Y-%m-%d")):
                            print('‚úÖjean645888258', date_formatted)
                            error_msg = f"‚ùå Erreur de format dans ligne:'{idx}' '{column}' : {value}"
                            print(error_msg)
                            log_message("succes_date_execution.txt", error_msg)
                            result_check=True
                        else:
                            print('Erreur sur le format de date', column,'-',value,'-',date_formatted)
                            print(f"Date invalide dans la colonne '{column}': {value}")
                            log_message("error_date_execution.txt", error_msg)
                            result_check=False
                    elif not isinstance(value, expected_type):
                            result_check=False
                            print(f"Erreur Type de donn√©e invalide dans la colonne '{column}': {value} n'est pas du type {expected_type}")
                            log_message("error_date_execution.txt", error_msg)

                    else:
                            result_check=True
                            log_message("succes_date_execution.txt", error_msg)

        error_msg=("‚úÖ Le fichier respecte les colonnes attendues et les types de donn√©es.",result_check)
        row_count = len(pdf)
        print('‚úÖLignes ',error_msg,row_count)
        log_message("statu_date_execution.txt", error_msg)

        return result_check

    except Exception as e:
        error_msg=(f"‚ùå Erreur de fiabilit√© : {str(e)}")
        print(error_msg)
        log_message("error_date_execution.txt", error_msg)

        return False





# D√©finir la t√¢che de v√©rification de fiabilit√© du fichier
def verify_file_reliability():
    files = [f for f in os.listdir(DIRECTORY_PATH) if os.path.splitext(f)[1] in ALLOWED_TYPES]
    for file in files:
        file_path = os.path.join(DIRECTORY_PATH, file)
        pdFile= read_file(file,file_path,ENCODINGS)
        if pdFile is not None:
            if check_file_reliability(pdFile):
                print('merci')
                return 'end'
            else:
                print('Merde')
                return 

        else:
            #Ecrire dans le log
            print(file_path,file,' non trait√© Boris',pdFile)
            return 







default_args = {
    "owner": "airflow",
    "start_date": datetime(2024, 1, 1),
}

with DAG("directory_and_file_verification_dag", default_args=default_args, 
             tags=['boris', 'bahi'],
             schedule_interval=None) as dag:

    # Premi√®re t√¢che : v√©rifier si le r√©pertoire existe
    check_directory_task = BranchPythonOperator(
        task_id="check_directory",
        python_callable=check_directory
    )

    # Deuxi√®me t√¢che : v√©rifier l'existence d'un type de fichier sp√©cifique
    check_file_task = BranchPythonOperator(
        task_id="check_file_in_directory",
        python_callable=check_file_in_directory
    )
    """
   # T√¢che 3: Lire chaque fichier si trouv√©
    read_files_task = BranchPythonOperator(
        task_id="read_files",
        python_callable=read_files
    )"""

    verify_file_reliability_task = BranchPythonOperator(
    task_id='verify_file_reliability',
    python_callable=verify_file_reliability,
)


    # T√¢che de fin si aucun fichier valide ou r√©pertoire inexistant
    end_task = EmptyOperator(task_id="end")

   # D√©finition des d√©pendances
    #check_directory_task >> check_file_task >> read_files_task >> verify_file_reliability_task >> end_task
    check_directory_task >> check_file_task >> verify_file_reliability_task >> end_task

    # Si le r√©pertoire n'existe pas, on termine directement
    check_directory_task >> end_task
    # Si aucun fichier n'est trouv√©, on termine directement
    check_file_task >> end_task
    
    #read_files_task >> end_task

    # Si la v√©rification des fichiers √©choue, on termine directement
    verify_file_reliability_task >> end_task